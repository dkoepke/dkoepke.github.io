---
layout: post-no-feature
title: "A Paean to the Monoliths"
description: "There no guarantees conferred by your architecture that cannot be undone by your implementation."
category: articles
tags: [distributed systems, architecture, service-oriented architecutre, SOA, micro-services, scalability, monolithic, software engineering]
---

Perhaps because they are so poorly understood, there is quite a lot of hype about service-oriented architectures (SOA) and micro-services. It is not that all of this hype is unjustified. When it comes to building beautiful software that meets all of its functional and business requirements, services can be a great tool. But all tools are ineffective when misunderstood, and the advantages and disadvantages of SOA are badly misunderstood.

Consider this criticism of non-service-oriented architecture in [Firat Atagun's Analysis of Software Architectures](http://www.firatatagun.com/blog/2016/01/09/analysis-of-software-architectures/):

<blockquote>While layered applications can perform well, since requests [have] to go through multiple layers, [they] might have performance problems.</blockquote>

Distributed systems are more vulnerable to this critique. They have more layers of greater complexity. The network, the marshalling layer, and the service bus or queue are all potential performance bottlenecks that require specialized knowledge to tune. A common mistake is to not even consider the performance impact of durability and availability of the service bus on your application. Once your queue must confirm writes, your throughput craters.

A related mistake is to think of your services as truly isolated. Service isolation is complete only in the sense that the code and the container running it are isolated. But the running services are certainly not isolated from each other. Services depend on each other or, at least, on the message bus or the network or the cluster hosting the containers. When you don't think about their side effects and how it can all go awry, you don't do the hard and interesting and necessary work of architecture. What happens if one of your services gets publish-happy? Will contention prevent other services from having their work handled? Fair queueing of reads is not a complete answer since a talkative service may consume the write capacity, delaying or preventing other services from publishing. There are a million little edge cases that crop up as your architecture accrues moving pieces.

So many analyses of software architecture ultimately fail because they ignore too much of the complexity of distributed architectures to ever get to their real advantages. Architects tend to overstate the scalability benefits of service-oriented architectures. *Service-oriented architectures perform worse, are less reliable, and are harder to scale than a comparably built monolithic application.* We all have horror stories of slow and crashy monolithic apps, but it's not as if the people that write terrible monolithic apps are going to start writing great services. It's not the architecture that's to blame. It's the people writing the code and the processes that allow technical debt to mount and monoliths to crumble to dust.

The real scalability benefit of a service-oriented architecture is that you can scale *your development teams*. For a while, your team's productivity increases with head count. But as you add more and more people, you need heavier weight processes, and your returns on productivity start to decrease. And there is an inflection point. At a certain size, the team's productivity will decrease. The answer is to have more, smaller teams that can work more independent of each other. But when it comes to scaling your application to support more *users*, service-oriented architectures are a form of cost engineering.

Monolithic software tends to require beefier hardware, but it's not necessarily impossible or even hard to horizontally scale monoliths. The real barrier to scalability is statefulness, and there's nothing inherently stateful to non-services. In fact, there is nothing inherently stateless about services. Plenty of people are building micro-service architectures that don't scale well. You still need to think about it and design for it. Smaller services tend to have cheaper hardware requirements, making them cheaper. Don't jump to services thinking they'll make you scale. Figure out how to scale, then figure out if services will help you get there on your budget.

Similarly, don't confuse the fact that service-oriented architectures give you more deployment options for the idea that services are *easier* to deploy. There are real benefits in having more deployment options, and some of those options might be simpler than the options available to a more monolithic application, but there are no guarantees conferred by your architectural choices that cannot be undone by your implementation. Services do not grant you zero downtime deploys. They do not grant you the ability to upgrade one piece without impacting other services. These are things you must build yourself.

I've seen this failure in real life. A data collector reports to two services which house different types of data and are completely independent of each other. But if you plotted the incoming data rates against the uptimes, you would see that when one service is down, the other stops writing data. When this was first observed, there was disbelief: the services are independent and do not talk to each other at all. But the collector talks to both services, and the collector is configured by one of the services. If that service carrying the configuration is down, the collector cannot send well-formed data to the other service. A lot of effort went into making these services independent of each other to end up at a place where they are inextricably tied together. It should've been seen from the very beginning, but the promise of services can blind you.

One of the reasons this glaring problem was missed is the flip-side of how services help you scale your teams. Having smaller teams that are more focused on delivering an individual service is great, but it increases the likelihood of your organization missing out on the big picture. You want your teams to *be* independent but not to *act* independently. When teams are dependent on each other, there are blockers that slow progress and create resentment. When teams act independently, they fail to communicate and don't deliver on the actual goals.

Failures in team communication lead to systemic failure, which is a frightening parallel to how failures in one service can rapidly spread to others. In my real world example, it was simply that one service's unavailability made both services unavailable. But it's also possible for service dependencies to spread through a system even when every component is available. Let's say one service is dealing with high load and so is running a few milliseconds slower than usual. Our next service down the line can adopt and magnify that latency--even in a fire-and-forget, asynchronous scenario--on connection. It doesn't take much to turn sub-optimal performance into timeouts, those timeouts into retries, and those excessive retries into something that deepens and prolongs an outage. We need to define operational constraints on our interfaces to make services fallback (and eventually fail) gracefully when their dependencies start to become unhealthy. Architecture analyses that don't mention circuit breakers are of no use. Architects that don't understand this aren't worth their titles.

There's an underlying theme in all of this. Architects sometimes paint service-oriented architectures as making various parts of life simpler and better. But all engineering is trade-offs. The real story of SOA is: more work has to go into coordination and collaboration. The devil is in the orchestration of services, the work of defining fallback behavior, the communication between independent teams, the forwards and backwards compatibility contracts, the wire protocols that leverage your network design. The industry at large needs to understand this better in order to build better software: every architecture has its cost, but you can't pay them if you don't acknowledge there's a bill. So maybe you shouldn't build a monolithic application in 2016, but what you absolutely must do is build systems that you and your team thoroughly understand. Even in 2016, those systems might look more like a monolith than micro-services.
